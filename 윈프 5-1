#include <windows.h>
#include <tchar.h>
#include "resource.h"

HINSTANCE g_hInst;
LPCTSTR IpszClass = L"Window Class Name";
LPCTSTR	IpszWindowName = L"Window Programming Lab";

LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPreInstance, LPSTR IpszCmdParam, int nCmdShow)
{
	HWND hWnd;
	MSG Message;
	WNDCLASSEX WndClass;
	g_hInst = hInstance;

	WndClass.cbSize = sizeof(WndClass);
	WndClass.style = CS_HREDRAW | CS_VREDRAW;
	WndClass.lpfnWndProc = (WNDPROC)WndProc;
	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.hInstance = hInstance;
	WndClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
	WndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	WndClass.lpszMenuName = NULL;
	WndClass.lpszClassName = IpszClass;
	WndClass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	RegisterClassEx(&WndClass);

	hWnd = CreateWindow(IpszClass, IpszWindowName, WS_OVERLAPPEDWINDOW, 0, 0, 1280, 1000, NULL, (HMENU)NULL, hInstance, NULL);

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	while (GetMessage(&Message, 0, 0, 0)) {
		TranslateMessage(&Message);
		DispatchMessage(&Message);
	}
	return Message.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	HDC hDC, hMemDC;
	static BITMAP bmp;
	static HBITMAP hBitmap;
	static RECT rect;
	static int x = 0, y = 0;
	static int mode = 0;

	switch (iMessage) {
	case WM_CREATE:
		hBitmap = (HBITMAP)LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP1));
		GetClientRect(hWnd, &rect);
		GetObject(hBitmap, sizeof(BITMAP), &bmp);
		x = bmp.bmWidth;
		y = bmp.bmHeight;
		break;
	case WM_PAINT:
		hDC = BeginPaint(hWnd, &ps);
		hMemDC = CreateCompatibleDC(hDC);
		(HBITMAP)SelectObject(hMemDC, hBitmap);
		if (mode == 0) StretchBlt(hDC, 0, 0, x, y, hMemDC, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);
		else if (mode == 1) StretchBlt(hDC, 0, 0, rect.right, rect.bottom, hMemDC, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);
		else if (mode == 2) {
			// 세로로 나눠서 왼쪽과 오른쪽에 출력
			int halfWidth = rect.right / 2;
			StretchBlt(hDC, 0, 0, halfWidth, rect.bottom, hMemDC, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);
			StretchBlt(hDC, halfWidth, 0, halfWidth, rect.bottom, hMemDC, 0, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);
		}

		DeleteDC(hMemDC);
		EndPaint(hWnd, &ps);
		break;
	case WM_CHAR:
		if (wParam == 'a' || wParam == 'A') {
			if (!mode) mode = 1;
			else if (mode) mode = 0;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == '=') {
			x += 10;
			y += 10;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == '-') {
			x -= 10;
			y -= 10;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == '1') {
			mode = 0;
			x = bmp.bmWidth;
			y = bmp.bmHeight;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == '2') {
			mode = 2;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == '3') {
			x = bmp.bmWidth;
			y = bmp.bmHeight;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == '4') {
			x = bmp.bmWidth;
			y = bmp.bmHeight;
			InvalidateRect(hWnd, NULL, TRUE);
		}
		else if (wParam == 'q' || wParam == 'Q') {
			PostQuitMessage(0);
			break;
		}
		break;
	case WM_DESTROY:
		//DeleteObject(hBitmap);
		PostQuitMessage(0);
		break;
	}
	return (DefWindowProc(hWnd, iMessage, wParam, lParam));
}
